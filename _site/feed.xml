<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DzX</title>
    <description></description>
    <link>http://crystalxian.github.io/</link>
    <atom:link href="http://crystalxian.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 15 Aug 2016 15:32:18 +0800</pubDate>
    <lastBuildDate>Mon, 15 Aug 2016 15:32:18 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Caffe Blob源码解读</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#blob&quot; id=&quot;markdown-toc-blob&quot;&gt;Blob源码解读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;blob&quot;&gt;Blob源码解读&lt;/h2&gt;

&lt;p&gt;补充Update()函数解读&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;有一篇较为完整的解析见&lt;a href=&quot;http://www.cnblogs.com/louyihang-loves-baiyan/p/5149628.html&quot;&gt;Blob解读&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中有些补充和更正&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Update&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;计算的是&lt;script type=&quot;math/tex&quot;&gt;data=-diff+data&lt;/script&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    caffe_axpy&amp;lt;Dtype&amp;gt;(count_, Dtype(-1),
	        static_cast&amp;lt;const Dtype*&amp;gt;(diff_-&amp;gt;cpu_data()),
			        static_cast&amp;lt;Dtype*&amp;gt;(data_-&amp;gt;mutable_cpu_data()));
	void caffe_axpy&amp;lt;float&amp;gt;(const int N, const float alpha, const float* X,
		      float* Y) { cblas_saxpy(N, alpha, X, 1, Y, 1); }
	\\其中两个1代表的是stride
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 15 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/08/15/Caffe-Blob/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/08/15/Caffe-Blob/</guid>
        
        <category>Caffe</category>
        
        <category>Blob</category>
        
        
        <category>Caffe</category>
        
      </item>
    
      <item>
        <title>Linux Skill</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#linux&quot; id=&quot;markdown-toc-linux&quot;&gt;linux的一些小技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;linux&quot;&gt;linux的一些小技巧&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;让一部分的代码退格&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;Crtl+v进入可视化
选中行数
大写I输入
大写D删除
输入想要的部分
再按ESC
—&lt;/p&gt;

</description>
        <pubDate>Fri, 12 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/08/12/Linux-Skill/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/08/12/Linux-Skill/</guid>
        
        <category>Linux</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>Caffe安装</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装两点记录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;安装两点记录&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU的安装Makefile.config&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;GPU的安装过程中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;出现的boost版本过高的问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cmake出错的问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;CPU安装在虚拟机上的&lt;a href=&quot;https://drive.google.com/open?id=0B1zyWUhQhBdWWkFxcG5KNS1WSDA&quot;&gt;Makefile.config&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加上（位置无所谓）&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LIBRARIES += glog gflags protobuf leveldb snappy \
             lmdb boost_system hdf5_hl hdf5 m \
             opencv_core opencv_highgui opencv_imgproc opencv_imgcodecs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;去掉’CPU_ONLY :=1’前面的注释&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果要用PYTHON_LAYER，去掉相应行前的注释&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/striker_v/article/details/51615197&quot;&gt;hdf5的错误&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial/
LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu/hdf5/serial /usr/include/hdf5/serial
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;GPU安装&lt;a href=&quot;https://drive.google.com/open?id=0B1zyWUhQhBdWdDR5ek5pTUNtcVE&quot;&gt;Makefile.config&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;boost版本需要&amp;lt;1.6，否则会有问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cmake的问题，SSD-caffe的安装也出现了这个问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: ‘memcpy’ was not declared in this scope
   return (char *) memcpy (__dest, __src, __n) + __n;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决方案&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd cmake-&amp;gt;cuda.cmake
   if(UNIX OR APPLE)
    	list(APPEND CUDA_NVCC_FLAGS -Xcompiler -fPIC -D_FORCE_INLINES)
   endif()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://cl.ly/2J1a1r103u2B/CUDA.png&quot; alt=&quot;compare&quot; /&gt;&lt;/p&gt;

&lt;p&gt;错误+解决方案&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error: make mistake  -lhdf5 cannot find
use cmake -DCMAKE-PREFIX-INSTALL=/anywhere you want 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 11 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/08/11/Caffe-Install/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/08/11/Caffe-Install/</guid>
        
        <category>Caffe</category>
        
        
        <category>Caffe</category>
        
      </item>
    
      <item>
        <title>SSD learning Note</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#intuition&quot; id=&quot;markdown-toc-intuition&quot;&gt;Intuition&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;摘要&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;主体部分&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#framework&quot; id=&quot;markdown-toc-framework&quot;&gt;Framework&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#auxiliary-stucture&quot; id=&quot;markdown-toc-auxiliary-stucture&quot;&gt;auxiliary stucture&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#train&quot; id=&quot;markdown-toc-train&quot;&gt;Train&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#rcnn&quot; id=&quot;markdown-toc-rcnn&quot;&gt;RCNN对照笔记&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#overfeat&quot; id=&quot;markdown-toc-overfeat&quot;&gt;OverFeat对照笔记&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#vocabulary&quot; id=&quot;markdown-toc-vocabulary&quot;&gt;Vocabulary&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSD的学习笔记。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;intuition&quot;&gt;Intuition&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于一个feature map(例如&lt;script type=&quot;math/tex&quot;&gt;38 \times 38&lt;/script&gt;)应用&lt;script type=&quot;math/tex&quot;&gt;3 \times 3&lt;/script&gt;的卷积层生成与feature map同等大小（&lt;script type=&quot;math/tex&quot;&gt;38 \times 38&lt;/script&gt;)的结果。对于一个这样的卷积层，输出结果是与之匹配的default boxes的Location的offset（xmin或xmax或ymin或ymax）或者是某个类别的confidence(21个类别)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;feature maps是多尺度的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有region proposal产生的过程，Single Shot = Single Network。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;摘要&lt;/h3&gt;
&lt;p&gt;Our approach, named SSD, &lt;strong&gt;discretizes&lt;/strong&gt; the output space of bounding boxes into a set of default boxes over different aspect ratios and scales per feature map location.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把bounding boxes离散化成每个特征图上拥有不同长宽比或不同尺度的原始boxes。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;网络对每个原始boxes中是否存在某个类别的物体进行打分的同时，对每个default boxes进行调整，使得其更好地match物体的形状。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;同时进行分类和回归？是的，offsets是一个回归的问题，类别一直都是一个分类问题。对于yolo和ssd直接利用一个网络判断物体分类和位置，而不再像Rcnn家族训练分别训练一个分类器和一个bounding boxes的回归器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以handle一张图片中有不同尺寸物体的问题。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;依旧需要resize图片，使用warp的方法。固定输入的size是&lt;script type=&quot;math/tex&quot;&gt;300\times300&lt;/script&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resize-mode:P.Resize.WARP&lt;/code&gt;（需要resize的原因：虽然没有全连接层，但是为了最后判断的时候输出固定。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不需要生成proposal和随后的降采样过程&lt;code class=&quot;highlighter-rouge&quot;&gt;针对RCNN&lt;/code&gt;，整个步骤整合为一个网络。&lt;code class=&quot;highlighter-rouge&quot;&gt;是提高速度的原因&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;速度：&lt;/p&gt;

&lt;p&gt;For &lt;script type=&quot;math/tex&quot;&gt;300 \times 300&lt;/script&gt; input, SSD achieves 69.8% mAP on VOC2007 test at 24 FPS on a GTX 980.
GTX980 | mAP |FPS|Video Memory |Batch Size&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;介绍&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;强调eliminating bounding box proposals and the subsequent pixel or feature resampling stage.&lt;code class=&quot;highlighter-rouge&quot;&gt;not the first one to do this work 相关：YOLO，OverFeat&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用一个小的卷积模板预测分类和bounding box location offsets的offsets&lt;code class=&quot;highlighter-rouge&quot;&gt;YOLO用了全连接层&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;实现多尺度的检测：在一个feature map上使用一组filters完成不同长宽比的检测，并且将这些filters应用到后来多级网络得到的不同的feature maps上。			 
这些使得输入一个低分辨率的图片就可以得到高准确率的检测结果。–&amp;gt;加速啊！&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一句总结core:predicting category scores and box offsets for a fixed set of default bounding boxes using small convolutional filters applied to feature maps.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;再强调一遍：In order to achieve high detection accuracy we produce predictions of different scales from feature maps of different scales, and explicitly separate predictions by aspect ratio.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;主体部分&lt;/h3&gt;

&lt;h4 id=&quot;framework&quot;&gt;Framework&lt;/h4&gt;

&lt;p&gt;SSD是基于一个前馈的卷积网络，网络的输入是固定大小的图片，输出是固定大小的张量。张量中包括bounding boxes和在这些boxes中存在某个类别物体的可能性。之后再利用non-maximum suppression做最后的检测。&lt;/p&gt;

&lt;p&gt;卷积网络结构：截取经典的分类网络，并称之为base work。在base work的基础上加上我们自己auxiliary structure。
截取分类层之前的网络是否有什么技巧？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VGGNetBody(net, from_layer=&#39;data&#39;, fully_conv=True, reduced=True, dilated=True,
    dropout=False, freeze_layers=freeze_layers)


def VGGNetBody(net, from_layer, need_fc=True, fully_conv=False, reduced=False,
        dilated=False, nopool=False, dropout=True, freeze_layers=[]):
    kwargs = {
            &#39;param&#39;: [dict(lr_mult=1, decay_mult=1), dict(lr_mult=2, decay_mult=0)],
            &#39;weight_filler&#39;: dict(type=&#39;xavier&#39;),
            &#39;bias_filler&#39;: dict(type=&#39;constant&#39;, value=0)}

    assert from_layer in net.keys()
    net.conv1_1 = L.Convolution(net[from_layer], num_output=64, pad=1, kernel_size=3, **kwargs)

    net.relu1_1 = L.ReLU(net.conv1_1, in_place=True)
    net.conv1_2 = L.Convolution(net.relu1_1, num_output=64, pad=1, kernel_size=3, **kwargs)
    net.relu1_2 = L.ReLU(net.conv1_2, in_place=True)

    if nopool:
        name = &#39;conv1_3&#39;
        net[name] = L.Convolution(net.relu1_2, num_output=64, pad=1, kernel_size=3, stride=2, **kwargs)
    else:
        name = &#39;pool1&#39;
        net.pool1 = L.Pooling(net.relu1_2, pool=P.Pooling.MAX, kernel_size=2, stride=2)

    net.conv2_1 = L.Convolution(net[name], num_output=128, pad=1, kernel_size=3, **kwargs)
    net.relu2_1 = L.ReLU(net.conv2_1, in_place=True)
    net.conv2_2 = L.Convolution(net.relu2_1, num_output=128, pad=1, kernel_size=3, **kwargs)
    net.relu2_2 = L.ReLU(net.conv2_2, in_place=True)

    if nopool:
        name = &#39;conv2_3&#39;
        net[name] = L.Convolution(net.relu2_2, num_output=128, pad=1, kernel_size=3, stride=2, **kwargs)
    else:
        name = &#39;pool2&#39;
        net[name] = L.Pooling(net.relu2_2, pool=P.Pooling.MAX, kernel_size=2, stride=2)

    net.conv3_1 = L.Convolution(net[name], num_output=256, pad=1, kernel_size=3, **kwargs)
    net.relu3_1 = L.ReLU(net.conv3_1, in_place=True)
    net.conv3_2 = L.Convolution(net.relu3_1, num_output=256, pad=1, kernel_size=3, **kwargs)
    net.relu3_2 = L.ReLU(net.conv3_2, in_place=True)
    net.conv3_3 = L.Convolution(net.relu3_2, num_output=256, pad=1, kernel_size=3, **kwargs)
    net.relu3_3 = L.ReLU(net.conv3_3, in_place=True)

    if nopool:
        name = &#39;conv3_4&#39;
        net[name] = L.Convolution(net.relu3_3, num_output=256, pad=1, kernel_size=3, stride=2, **kwargs)
    else:
        name = &#39;pool3&#39;
        net[name] = L.Pooling(net.relu3_3, pool=P.Pooling.MAX, kernel_size=2, stride=2)

    net.conv4_1 = L.Convolution(net[name], num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu4_1 = L.ReLU(net.conv4_1, in_place=True)
    net.conv4_2 = L.Convolution(net.relu4_1, num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu4_2 = L.ReLU(net.conv4_2, in_place=True)
    net.conv4_3 = L.Convolution(net.relu4_2, num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu4_3 = L.ReLU(net.conv4_3, in_place=True)

    if nopool:
        name = &#39;conv4_4&#39;
        net[name] = L.Convolution(net.relu4_3, num_output=512, pad=1, kernel_size=3, stride=2, **kwargs)
    else:
        name = &#39;pool4&#39;
        net[name] = L.Pooling(net.relu4_3, pool=P.Pooling.MAX, kernel_size=2, stride=2)

    net.conv5_1 = L.Convolution(net[name], num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu5_1 = L.ReLU(net.conv5_1, in_place=True)
    net.conv5_2 = L.Convolution(net.relu5_1, num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu5_2 = L.ReLU(net.conv5_2, in_place=True)
    net.conv5_3 = L.Convolution(net.relu5_2, num_output=512, pad=1, kernel_size=3, **kwargs)
    net.relu5_3 = L.ReLU(net.conv5_3, in_place=True)

    if need_fc:
        if dilated:
            if nopool:
                name = &#39;conv5_4&#39;
                net[name] = L.Convolution(net.relu5_3, num_output=512, pad=1, kernel_size=3, stride=1, **kwargs)
            else:
                name = &#39;pool5&#39;
                net[name] = L.Pooling(net.relu5_3, pool=P.Pooling.MAX, pad=1, kernel_size=3, stride=1)
        else:
            if nopool:
                name = &#39;conv5_4&#39;
                net[name] = L.Convolution(net.relu5_3, num_output=512, pad=1, kernel_size=3, stride=2, **kwargs)
            else:
                name = &#39;pool5&#39;
                net[name] = L.Pooling(net.relu5_3, pool=P.Pooling.MAX, kernel_size=2, stride=2)

        if fully_conv:
            if dilated:
                if reduced:
                    net.fc6 = L.Convolution(net[name], num_output=1024, pad=6, kernel_size=3, dilation=6, **kwargs)
                else:
                    net.fc6 = L.Convolution(net[name], num_output=4096, pad=6, kernel_size=7, dilation=2, **kwargs)
            else:
                if reduced:
                    net.fc6 = L.Convolution(net[name], num_output=1024, pad=3, kernel_size=3, dilation=3, **kwargs)
                else:
                    net.fc6 = L.Convolution(net[name], num_output=4096, pad=3, kernel_size=7, **kwargs)

            net.relu6 = L.ReLU(net.fc6, in_place=True)
            if dropout:
                net.drop6 = L.Dropout(net.relu6, dropout_ratio=0.5, in_place=True)

            if reduced:
                net.fc7 = L.Convolution(net.relu6, num_output=1024, kernel_size=1, **kwargs)
            else:
                net.fc7 = L.Convolution(net.relu6, num_output=4096, kernel_size=1, **kwargs)
            net.relu7 = L.ReLU(net.fc7, in_place=True)
            if dropout:
                net.drop7 = L.Dropout(net.relu7, dropout_ratio=0.5, in_place=True)
        else:
            net.fc6 = L.InnerProduct(net.pool5, num_output=4096)
            net.relu6 = L.ReLU(net.fc6, in_place=True)
            if dropout:
                net.drop6 = L.Dropout(net.relu6, dropout_ratio=0.5, in_place=True)
            net.fc7 = L.InnerProduct(net.relu6, num_output=4096)
            net.relu7 = L.ReLU(net.fc7, in_place=True)
            if dropout:
                net.drop7 = L.Dropout(net.relu7, dropout_ratio=0.5, in_place=True)

    # Update freeze layers.
    kwargs[&#39;param&#39;] = [dict(lr_mult=0, decay_mult=0), dict(lr_mult=0, decay_mult=0)]
    layers = net.keys()
    for freeze_layer in freeze_layers:
        if freeze_layer in layers:
            net.update(freeze_layer, kwargs)

    return net
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;auxiliary-stucture&quot;&gt;auxiliary stucture&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获得多尺度的特征图。卷积特征层被加到了被截断的base network后面，来实现多尺度的检测。每一个特征层上用来预测识别的卷积模型都不一样。【对比：YOLO和Overfeat在一个尺度图上做预测识别】&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;识别的卷积预测。每一个特征层上都可以利用一组卷积滤波器产生一组确定数目的识别预测。对于每一个特征图（&lt;script type=&quot;math/tex&quot;&gt;m\times n \times p&lt;/script&gt;），用(&lt;script type=&quot;math/tex&quot;&gt;3 \times 3\times p&lt;/script&gt;)的kernel，得到对某个类别的评分或者相对default box坐标的shape offset.The bounding box offset output values are measured relative to a default box postion relative to each feature map location.
&lt;img src=&quot;https://s3.amazonaws.com/f.cl.ly/items/2i1O2h0j302W3e0u2D40/ssdframe.png&quot; alt=&quot;图1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Default Boxes：&lt;strong&gt;在一些不同尺度（&lt;script type=&quot;math/tex&quot;&gt;8\times8或者4\times4&lt;/script&gt;）的特征图的每个位置上，我们给出（估计）一小组（4个）有着不同长宽比的原始boxes，如下图所示。&lt;/strong&gt;对于每一个原始box，我们预测shape offsets和评估在这个box内中可能有的物体类别。具体来说，对于一个（&lt;script type=&quot;math/tex&quot;&gt;m\times n&lt;/script&gt;）大小的特征图，每一个位置上都有k个相应的default boxes，对于每个default box我们需要对c类物体的评估分和4个offsets，所以对于一个特征图需要(c+4)kmn个输出。这与anchor boxes&lt;code class=&quot;highlighter-rouge&quot;&gt;Faster Rcnn&lt;/code&gt;相似。【不一样的部分是SSD用在多尺度上】&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;train&quot;&gt;Train&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;Match default boxes和ground truth boxes。如上图所示。方法paper上很简略，看起来应该跟Faster Rcnn一毛一样。（阈值不同）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;rcnn&quot;&gt;RCNN对照笔记&lt;/h4&gt;
&lt;p&gt;究极版RCNN–&lt;strong&gt;Faster Rcnn&lt;/strong&gt;
1. 实现：
hypothesize bounding boxes-&amp;gt;resample pixels or features for each box-&amp;gt;apply a high-quality classfier
2. 优缺点：
* 优点：所有分类和检测大赛上的头名【use deep network–ResNetwork】
* 缺点：计算量大，不能实时。【具体数据7FPS-the basic Faster Rcnn】
3. 细节
&lt;img src=&quot;https://s3.amazonaws.com/f.cl.ly/items/1n3r022J2y162b1W2K3Z/anchor_1.png&quot; alt=&quot;center&quot; /&gt; Faster Rcnn 中anchor的实现
* anchor【default boxes】The k proposals are parameterized relative to k reference boxes, which we call &lt;em&gt;anchors&lt;/em&gt;. An anchor is centered at the sliding window in question, and is associated with a scale and aspect ratio. 一般有三种尺度，三种长宽比。这里的sliding window 用$n\times n$的卷积层实现，对于每一个被卷积层作用的卷积特征图（$W \times H$）有$W \times H \times k$个anchors。
		 *  anchor和计算proposal的方法具有平移不变性。如果一个物体在图像中平移，这个特征也相应的平移，并且相同的方法能够在任意位置预测出这个特征。【对比MultiBox的anchor就没有平移不变性】
				 *  提供一种多尺度预测的新方法。老方法一：基于图像\特征图的金字塔。老方法二：基于多尺度的sliding window\滤波器金字塔。anchor提供的方法是多尺度的anchor，most cost-efficient。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;					          重大意义在于The design of multiscale anchors is a key component for sharing features without extra cost for addressing scales.
							   ![|center](https://s3.amazonaws.com/f.cl.ly/items/0J3v1s0n1V0K3p3n0b1P/anchor_2.png)
							   Faster Rcnn的loss function
							   1. 判断每个anchor中是否有物体。positive label两种情况(1)anchor和ground-truth box有最大的IOU(2)anchor和ground-truth box IOU值大于阈值(0.7) negative label的情况：non-positive anchor跟所有的ground-truth boxes的IOU小于一个阈值(0.3)非正也非负的anchors 不参与training
							   2. objective function
							   $$ L({p_i},{t_i})= \frac{1}{N_{cls}}\sum_iL_{cls}(p_i,p_i^*) +\lambda\frac{1}{N_{reg}}\sum_ip_i^*L_{reg}(t_i,t_i^*)$$
							   $p_i^*=1$anchor为positive的时候。$p_i$我们网络计算出来的anchor i中是物体的概率。
							   $L_{reg}(t_i,t_i^*)= R(t_i,t_i^*)$  R is the robust loss function.
							   $p_i^*L_{reg}$只有当anchor是positive的时候($p_i^*=1$)，才有值。
							   bounding box regression
							   ![|center](https://s3.amazonaws.com/f.cl.ly/items/2y063r111r0D041H3Z18/boundingboxreg.png) #### YOLO对照笔记
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;overfeat&quot;&gt;OverFeat对照笔记&lt;/h4&gt;
&lt;p&gt;#### SPP对照笔记
什么是crop和wrap？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://d3dr1ze7164817.cloudfront.net/items/2b0Q2F2C3R0P2Y1U3V0h/crop_wrap.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;vocabulary&quot;&gt;Vocabulary&lt;/h5&gt;
&lt;p&gt;utilize 利用         prevail 盛行
albeit 即使，尽管      high-end 高档
truncate 截断        auxiliary 附加的
be fed into 送入       analogous相似的&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/29/Single-Shot-MultiBox/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/29/Single-Shot-MultiBox/</guid>
        
        <category>SSD</category>
        
        <category>CNN</category>
        
        <category>Detection</category>
        
        
        <category>Object-Detection</category>
        
      </item>
    
      <item>
        <title>Obeject Detection基础知识理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#obejectdetection-&quot; id=&quot;markdown-toc-obejectdetection-&quot;&gt;ObejectDetection 的基本知识理解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#roc&quot; id=&quot;markdown-toc-roc&quot;&gt;ROC曲线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;obejectdetection-&quot;&gt;ObejectDetection 的基本知识理解&lt;/h2&gt;

&lt;p&gt;Recall，precision, Roc等&lt;/p&gt;

&lt;h2 id=&quot;roc&quot;&gt;ROC曲线&lt;/h2&gt;
&lt;p&gt;ROC: receiver operating characteristic curve
ss rate = &lt;script type=&quot;math/tex&quot;&gt;\sum_{i=1}^n a_i=0&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;True/False代表判断是对/错的，Positive/Negative代表判断结果，判断分类与对错无关。
*  True Positive: 判断是正确的，判断结果是正的。
*  False Positive:判断是错误的，判断结果是正的。也就是说实际上结果应该是负的，我们判断它是正的，所以我们错了。
*  True Negative: 判断是正确的，判断结果是负的。
*  False Negative:判断是错误的，判断结果是负的。
 Precision Recall理解
&lt;img src=&quot;http://d.pr/i/ZK07&quot; alt=&quot;一张图理解上述知识&quot; /&gt;
* Precision rate = 
* Recall rate = 
* Miss rate = &lt;script type=&quot;math/tex&quot;&gt;\sum_{i=1}^n a_i=0&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/25/ObjectDetection-Base/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/25/ObjectDetection-Base/</guid>
        
        <category>物体识别</category>
        
        
        <category>ObejectDetection</category>
        
      </item>
    
      <item>
        <title>Latex+Sublime+Windows笔记</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;笔记概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;准备工作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;笔记概述&lt;/h3&gt;

&lt;p&gt;TexLive+Sbulime+LatexTools+SumatraPDF
一个学期在渣笔记本上用WinEdt，觉得越用越不好用。趁有新的电脑，所以专门在知乎上转了一圈，发现大神推荐了这个配置，所以就毫不犹豫的下手了。这篇笔记主要总结一下自己迈过去的一些配置的坑。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sublimetext.com/blog/articles/sublime-text-3-build-3103&quot;&gt;sublime 3 官网&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;D:\software\Sublime Text 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet/&quot;&gt;texlive 2016清华镜像&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;windows用户直接下载一个.exe就好，不用去下源包。安装时间较长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sumatrapdfreader.org/free-pdf-reader.html&quot;&gt;sumatrapdf官网&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;C:\Program Files&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 24 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/24/Latex-Texlive-Sublime/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/24/Latex-Texlive-Sublime/</guid>
        
        <category>Latex</category>
        
        <category>排版</category>
        
        <category>Texlive</category>
        
        
        <category>Latex</category>
        
      </item>
    
      <item>
        <title>SSD learning Note</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;综述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;相关工作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SSD的学习笔记。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section&quot;&gt;综述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Our approach, named SSD, discretizes the output space of bounding boxes into a set of bounding box priors over different aspect ratios and scales per feature map location.&lt;/p&gt;

    &lt;p&gt;理解：diescretizes？priors？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It completely discards the proposal generation step and encapsulates all the computation in a single network.&lt;/p&gt;

    &lt;p&gt;亮点：makes SSD easy to train and straightforward to intergrate into systems that require a detection component.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;介绍&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Region-based Convolutional Neural Networks(R-CNN) or its faster variants approach detection as a classification problem over object proposals, followed by (optional) regression of the bounding box coordinates.&lt;/p&gt;

    &lt;p&gt;理解：R-CNN根据selective search选出region proposals，在利用CNN进行分类后，得到一系列的有类别（类别概率）的region proposals。通过nms的方法得到想要的bounding box（？）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Given a set of fixed bounding box priors of different aspect ratios and scales, we train a network to select which priors contain objects of interest and adjust their coordinates to better match the object’s shape.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In our method, the offset adjustment and confidences for multiple categories of each prior are predicted from the underlying 1x1 feature at each location on a feature map, as opposed to the whole feature map as done in MultiBox and Yolo.&lt;/p&gt;

    &lt;p&gt;主要的实现方式如下图所示：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

 	&lt;img src=&quot;/assets/ssd_intro.png&quot; alt=&quot;&quot; /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;理解:？ * The set of bounding box priors we define is in the same spirit as the anchor boxes used in the Faster R-CNN.

分析：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;SSD is the first work to combine the idea of convolutional bounding box priors with the ability to predict multiple object categories.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-2&quot;&gt;相关工作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Faster-RCNN replaces selective search proposals by ones learned from a region proposal network(RPN), and introduces a method to integrate the RPN with Fast R-CNN by alternating between fine-tuning shared convolutional layers and prediction layers for these two networks.
  借鉴了anchor boxes的观点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If we only use one prior per location freom the topmost feature map,our SSD has similar architecture as OverFeat; if we use the whole topmost feature map for predictions instead of using the convolutional priors, we can approximately reproduce YOLO.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Training&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;用bi来代表每一个priors.每一个prior都包含bounding box和一系列物体类别的置信度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;预测box的坐标是通过把网络计算出的offsets加到相应的priors上，所有priors和ground truth boxes都是相对于全图的归一化坐标。’解释’ 归一化的坐标使得我们不必担心输入图片的大小问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;匹配问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文不定期更新。&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/19/Single-Shot-MultiBox-Detector/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/19/Single-Shot-MultiBox-Detector/</guid>
        
        <category>SSD</category>
        
        <category>CNN</category>
        
        <category>Detection</category>
        
        
        <category>Object-Detection</category>
        
      </item>
    
      <item>
        <title>R-Cnn算法理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#rcnn&quot; id=&quot;markdown-toc-rcnn&quot;&gt;Rcnn是使用深度学习进行物体检测的开山之作。&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;基础知识&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rcnn&quot;&gt;Rcnn是使用深度学习进行物体检测的开山之作。&lt;/h2&gt;

&lt;h2 id=&quot;section&quot;&gt;基础知识&lt;/h2&gt;
&lt;p&gt;** IOU的定义
物体检测需要定位出物体的bounding box，不仅需要我们可以分辨出这个物体是车，还需要我们知道这个车的bounding box。IOU是定义bounding box定位精度的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160314191626423&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/17/faster-rcnn-settings-cpu/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/17/faster-rcnn-settings-cpu/</guid>
        
        <category>Rcnn</category>
        
        <category>caffe</category>
        
        <category>物体识别</category>
        
        
        <category>Rcnn</category>
        
      </item>
    
      <item>
        <title>Faster RCNN cpu</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;解决方法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;原来的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;我们每次使用命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@gitlab.xxx.com:xxxxx.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在&lt;code class=&quot;highlighter-rouge&quot;&gt;daily/1.4.1&lt;/code&gt;分支上，我们希望拿到这个分支上的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2016/07/07/577e349ab42ed.png&quot; alt=&quot;7f07c8f6deef169ef6be5103bbd3e932f8676bb1.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;刚刚开周会的时候，自己洋洋得意的分享我的解决方案，但是……经过与团队成员的的讨论，自己的方法弱爆了，现在把更优雅的方法写一下。原来写的方法并不太适合用在这个场景里。&lt;/strong&gt; 我之前写的方法在文章后面。&lt;/p&gt;

&lt;p&gt;直接使用命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch -r #查看远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch -a #查看所有分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会显示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;origin/HEAD -&amp;gt; origin/master
origin/daily/1.2.2
origin/daily/1.3.0
origin/daily/1.4.1
origin/develop
origin/feature/daily-1.0.0
origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后直接&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout origin/daily/1.4.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就好了。。。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;原来的解决方案&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;其实我原来写的这个方法更多的是：设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在本地先建立一个分支，建议名称和远程的想要同步的分支名称一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch daily/1.4.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在切换到这个本地分支&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout daily/1.4.1
# Switched to branch &#39;daily/1.4.1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来就可以去建立上游分支的关联了，但是这个命令比较长，不好记，我们可以直接先&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;一下，git 会提示我们相应的操作和命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git pull
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
See git-pull(1) for details.

    git pull &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;

If you wish to set tracking information for this branch you can do so with:

    git branch --set-upstream-to=origin/&amp;lt;branch&amp;gt; daily/1.4.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们看到最后一行，执行这个命令，即可完成与上游分支的关联。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git branch --set-upstream-to=origin/daily/1.4.1 daily/1.4.1
# Branch daily/1.4.1 set up to track remote branch daily/1.4.1 from origin.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后再&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;一下就好了！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/07/07/git-clone-not-master-branch/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/07/07/git-clone-not-master-branch/</guid>
        
        <category>Faster</category>
        
        <category>RCNN</category>
        
        <category>caffe</category>
        
        
        <category>Faster</category>
        
        <category>Rcnn</category>
        
      </item>
    
      <item>
        <title>如何使用 babel</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#babel-cli&quot; id=&quot;markdown-toc-babel-cli&quot;&gt;babel-cli&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#babel-cli-1&quot; id=&quot;markdown-toc-babel-cli-1&quot;&gt;在项目内运行 babel-cli&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#babelrc&quot; id=&quot;markdown-toc-babelrc&quot;&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jshintrc&quot; id=&quot;markdown-toc-jshintrc&quot;&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.jshintrc&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 用于将 ES6 的代码转化为 ES5，使得 ES6 可以在目前的浏览器环境下使用。学习使用 babel 是为了使用 ES2015 做准备。本文将介绍如何使用 babel，以及一些相关的配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://babeljs.io/images/logo.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;学习 Babel 可以通过其手册 Babel handbook。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/thejameskyle/babel-handbook&quot;&gt;babel-handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中包含多语言版本，分为&lt;a href=&quot;https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md&quot;&gt;用户手册&lt;/a&gt;和&lt;a href=&quot;https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md&quot;&gt;插件手册&lt;/a&gt;。这是一个很好的学习 Babel 的资料。&lt;/p&gt;

&lt;h2 id=&quot;babel-cli&quot;&gt;babel-cli&lt;/h2&gt;

&lt;p&gt;在 node 和 npm 环境安装好的前提下，安装 babel，如下：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --global babel-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后就可以编译文件了。&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;babel main.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译后的文件显示在终端上，可以添加其他命令让它输出到指定文件下：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;babel example.js --out-file compiled.js
或
babel example.js -o compiled.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或将整个目录编译成一个新的目录：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;babel src --out-dir lib
或
babel src -d lib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但这很麻烦，并且并不是一个很好的解决方案，请看下一节项目内运行 babel-cli。&lt;/p&gt;

&lt;h2 id=&quot;babel-cli-1&quot;&gt;在项目内运行 babel-cli&lt;/h2&gt;

&lt;p&gt;初始化项目&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再安装 babel-cli&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save-dev babel-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;项目中的&lt;code class=&quot;highlighter-rouge&quot;&gt;package.json&lt;/code&gt;应该包含如下内容：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;learn-es6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;devDependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;babel-cli&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^6.10.1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加 npm scripts 命令。&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;learn-es6&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
&lt;span class=&quot;gi&quot;&gt;+   &quot;scripts&quot;: {
+     &quot;build&quot;: &quot;babel src -d lib&quot;
+   },
&lt;/span&gt;  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.10.1&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时在终端里运行&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还不能成功编译，因为没有配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;文件。&lt;/p&gt;

&lt;h2 id=&quot;babelrc&quot;&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;通过配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;来告诉 babel 来做什么。&lt;/p&gt;

&lt;p&gt;在项目的根路径下创建&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;文件。然后输入以下内容作为开始：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;presets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;plugins&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了让 babel 将 ES2015 转化为 ES5，我们要安装如下：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install --save-dev babel-preset-es2015
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完成后在&lt;code class=&quot;highlighter-rouge&quot;&gt;.babelrc&lt;/code&gt;中添加参数：&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;presets&quot;: [
&lt;span class=&quot;gi&quot;&gt;+       &quot;es2015&quot;
&lt;/span&gt;    ],
    &quot;plugins&quot;: []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在在项目&lt;code class=&quot;highlighter-rouge&quot;&gt;src/main.js&lt;/code&gt;中写一些 ES2015 的代码试试吧。&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在终端中输入命令&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行后终端中显示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; learn-es6@1.0.0 build c:\gitWorkSpace\learn-es6
&amp;gt; babel src -d lib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后可以看到目录中出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/main.js&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;use strict&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;即编译成功。&lt;/p&gt;

&lt;h2 id=&quot;jshintrc&quot;&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;.jshintrc&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;若编辑器中安装了 jshint 语法检查的插件。默认对于 ES2015 的代码可能会报错或者警告，看着可能会不爽。我们可以在配置文件中将它设置为允许 ES2015 的模式。&lt;/p&gt;

&lt;p&gt;在项目根目录下创建文件&lt;code class=&quot;highlighter-rouge&quot;&gt;.jshintrc&lt;/code&gt;。内容如下：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;asi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;esversion&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2015&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述文件我分别设置了，使用无分号模式，es 版本使用 2015。&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;.jshintrc&lt;/code&gt;的更详细配置可以参见官方示例：&lt;a href=&quot;https://github.com/jshint/jshint/blob/master/examples/.jshintrc&quot;&gt;https://github.com/jshint/jshint/blob/master/examples/.jshintrc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;好，babel 就说到这里，下面开始进入真正的 ES2015 的学习！&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://crystalxian.github.io/2016/06/14/how-to-use-babel/</link>
        <guid isPermaLink="true">http://crystalxian.github.io/2016/06/14/how-to-use-babel/</guid>
        
        <category>ES2015</category>
        
        <category>ES6</category>
        
        <category>ES5</category>
        
        <category>babel</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
  </channel>
</rss>
